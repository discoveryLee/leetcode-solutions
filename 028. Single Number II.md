# 只出现一次的数字 II
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。  
说明：  
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？  
示例 1:
>输入: [2,2,3,2]  
输出: 3

示例 2:
>输入: [0,1,0,1,0,1,99]  
输出: 99  

我们沿用**位运算**的思路：如果一个数字出现三次，那么它的二进制表示的每一位（0或1）也出现三次。如果把所有出现三次的数字的二进制表示的每一位都分别加起来，那么每一位的和都能被3整除。
代码如下：
```
class Solution {
    //int 整型共有32位，统计这n个数据每个二进制位上1出现的个数，再%3，
    //如果为1，那说明这一位是要找元素二进制表示中为1 的那一位。
    public int singleNumber(int[] nums) {
        int result=0;
        for(int i=0;i<32;i++){
            int bit=0;//每个二进制位上1出现的个数
            for(int j=0;j<nums.length;j++){
                    bit+=(nums[j]>>i)&1;
            }
           result|=(bit%3)<<i;
        }
        return result;
    }
}
```
